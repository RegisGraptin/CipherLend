{
  "address": "0x612Bb040df7E14E712c2eAD949ECe9d137bcE471",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "LiquiditySupplied",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "LiquidityWithdrawn",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "underlying",
          "type": "address"
        }
      ],
      "name": "fetchAssets",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1ccf6f3d49d7270b69cc4e85265a5d12182919dcdc3d7a513d797dad15826f04",
  "receipt": {
    "to": null,
    "from": "0x8592B0EaCfe731AD97b6Ed7e753A692d6Eb48a7D",
    "contractAddress": "0x612Bb040df7E14E712c2eAD949ECe9d137bcE471",
    "transactionIndex": 124,
    "gasUsed": "240973",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x626b6976b1474189d19c54073b7c82d7cf8c548defdd822bcb85e5b43f2bcbc4",
    "transactionHash": "0x1ccf6f3d49d7270b69cc4e85265a5d12182919dcdc3d7a513d797dad15826f04",
    "logs": [],
    "blockNumber": 10169992,
    "cumulativeGasUsed": "12634716",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "0b74d0ee8627b7b594945c5c338dc89b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiquiditySupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"fetchAssets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"AAVE Documentation https://github.com/aave-dao/aave-v3-origin\",\"events\":{\"LiquiditySupplied(uint256)\":{\"params\":{\"amount\":\"Amount supplied\"}},\"LiquidityWithdrawn(uint256)\":{\"params\":{\"amount\":\"Amount withdrawn\"}}},\"kind\":\"dev\",\"methods\":{\"fetchAssets(address,address)\":{\"params\":{\"pool\":\"AAVE pool address\",\"underlying\":\"Underlying asset address\"},\"returns\":{\"_0\":\"aToken address\"}}},\"title\":\"AaveAdapter\",\"version\":1},\"userdoc\":{\"events\":{\"LiquiditySupplied(uint256)\":{\"notice\":\"Emitted when liquidity is supplied to AAVE\"},\"LiquidityWithdrawn(uint256)\":{\"notice\":\"Emitted when liquidity is withdrawn from AAVE\"}},\"kind\":\"user\",\"methods\":{\"fetchAssets(address,address)\":{\"notice\":\"Fetch the aToken address for a given underlying asset from AAVE pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AAVEAdapter.sol\":\"AaveAdapter\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"keccak256\":\"0xd5ea07362ab630a6a3dee4285a74cf2377044ca2e4be472755ad64d7c5d4b69d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0x0afcb7e740d1537b252cb2676f600465ce6938398569f09ba1b9ca240dde2dfc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0x1a6221315ce0307746c2c4827c125d821ee796c74a676787762f4778671d4f44\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"keccak256\":\"0x982c5cb790ab941d1e04f807120a71709d4c313ba0bfc16006447ffbd27fbbd5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8891738ffe910f0cf2da09566928589bf5d63f4524dd734fd9cedbac3274dd5c\",\"license\":\"MIT\"},\"contracts/AAVEAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.27;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IPool} from \\\"lib/aave-v3-origin/src/contracts/interfaces/IPool.sol\\\";\\nimport {DataTypes} from \\\"lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title AaveAdapter\\n * @dev AAVE Documentation https://github.com/aave-dao/aave-v3-origin\\n */\\nlibrary AaveAdapter {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice Emitted when liquidity is supplied to AAVE\\n     * @param amount Amount supplied\\n     */\\n    event LiquiditySupplied(uint256 amount);\\n\\n    /**\\n     * @notice Emitted when liquidity is withdrawn from AAVE\\n     * @param amount Amount withdrawn\\n     */\\n    event LiquidityWithdrawn(uint256 amount);\\n\\n    /**\\n     * @notice Fetch the aToken address for a given underlying asset from AAVE pool\\n     * @param pool AAVE pool address\\n     * @param underlying Underlying asset address\\n     * @return aToken address\\n     */\\n    function fetchAssets(address pool, address underlying) public view returns (address) {\\n        DataTypes.ReserveDataLegacy memory reserve = IPool(pool).getReserveData(underlying);\\n        return reserve.aTokenAddress;\\n    }\\n\\n    /**\\n     * @notice Supply assets to AAVE pool\\n     * @param asset Address of the ERC20 asset\\n     * @param pool AAVE pool address\\n     * @param amount Amount to supply\\n     * @dev We expect the amount to not be zero\\n     */\\n    function supplyToAave(address asset, address pool, uint256 amount) internal {\\n        IERC20(asset).approve(pool, amount);\\n        IPool(pool).supply(address(asset), amount, address(this), 0);\\n        emit LiquiditySupplied(amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw assets from AAVE pool\\n     * @param asset Address of the ERC20 asset\\n     * @param pool AAVE pool address\\n     * @param requestedAmount Amount to withdraw\\n     * @dev We expect the amount to not be zero\\n     */\\n    function withdrawFromAave(\\n        address asset,\\n        address pool,\\n        uint256 requestedAmount\\n    ) internal returns (uint256 withdrawnAmount) {\\n        // TODO: Case to be handle later on\\n        // How can we manage the case where AAVE does not have enough liquidity?\\n\\n        // DataTypes.ReserveData memory reserve = POOL.getReserveData(asset);\\n        // uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\\n        // withdrawn = requestedAmount > availableLiquidity ? availableLiquidity : requestedAmount;\\n        // if (withdrawn > 0) {\\n        //     POOL.withdraw(asset, withdrawn, address(this));\\n        // }\\n\\n        withdrawnAmount = IPool(pool).withdraw(address(asset), requestedAmount, address(this));\\n        emit LiquidityWithdrawn(withdrawnAmount);\\n    }\\n}\\n\",\"keccak256\":\"0xc2fd31eaf5949f70766524b32579e373b02988ee79dbd60cb3f457b6b96013d4\",\"license\":\"MIT\"},\"lib/aave-v3-origin/src/contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\\n\\n/**\\n * @title IPool\\n * @author Aave\\n * @notice Defines the basic interface for an Aave Pool.\\n */\\ninterface IPool {\\n  /**\\n   * @dev Emitted on supply()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the supply\\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\\n   * @param amount The amount supplied\\n   * @param referralCode The referral code used\\n   */\\n  event Supply(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param reserve The address of the underlying asset being withdrawn\\n   * @param user The address initiating the withdrawal, owner of aTokens\\n   * @param to The address that will receive the underlying\\n   * @param amount The amount to be withdrawn\\n   */\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /**\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n   * initiator of the transaction on flashLoan()\\n   * @param onBehalfOf The address that will be getting the debt\\n   * @param amount The amount borrowed out\\n   * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)\\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\\n   * @param referralCode The referral code used\\n   */\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    DataTypes.InterestRateMode interestRateMode,\\n    uint256 borrowRate,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\n   * @param amount The amount repaid\\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\\n   */\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount,\\n    bool useATokens\\n  );\\n\\n  /**\\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param totalDebt The total isolation mode debt for the reserve\\n   */\\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\\n\\n  /**\\n   * @dev Emitted when the user selects a certain asset category for eMode\\n   * @param user The address of the user\\n   * @param categoryId The category id\\n   */\\n  event UserEModeSet(address indexed user, uint8 categoryId);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   */\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   */\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on flashLoan()\\n   * @param target The address of the flash loan receiver contract\\n   * @param initiator The address initiating the flash loan\\n   * @param asset The address of the asset being flash borrowed\\n   * @param amount The amount flash borrowed\\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan,\\n   *        1 for Stable (Deprecated on v3.2.0), 2 for Variable\\n   * @param premium The fee flash borrowed\\n   * @param referralCode The referral code used\\n   */\\n  event FlashLoan(\\n    address indexed target,\\n    address initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    DataTypes.InterestRateMode interestRateMode,\\n    uint256 premium,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted when a borrower is liquidated.\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\\n   * @param liquidator The address of the liquidator\\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   */\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveAToken\\n  );\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated.\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param liquidityRate The next liquidity rate\\n   * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0\\n   * @param variableBorrowRate The next variable borrow rate\\n   * @param liquidityIndex The next liquidity index\\n   * @param variableBorrowIndex The next variable borrow index\\n   */\\n  event ReserveDataUpdated(\\n    address indexed reserve,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when the deficit of a reserve is covered.\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param caller The caller that triggered the DeficitCovered event\\n   * @param amountCovered The amount of deficit covered\\n   */\\n  event DeficitCovered(address indexed reserve, address caller, uint256 amountCovered);\\n\\n  /**\\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\\n   * @param reserve The address of the reserve\\n   * @param amountMinted The amount minted to the treasury\\n   */\\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\n\\n  /**\\n   * @dev Emitted when deficit is realized on a liquidation.\\n   * @param user The user address where the bad debt will be burned\\n   * @param debtAsset The address of the underlying borrowed asset to be burned\\n   * @param amountCreated The amount of deficit created\\n   */\\n  event DeficitCreated(address indexed user, address indexed debtAsset, uint256 amountCreated);\\n\\n  /**\\n   * @dev Emitted when a position manager is approved by the user.\\n   * @param user The user address\\n   * @param positionManager The address of the position manager\\n   */\\n  event PositionManagerApproved(address indexed user, address indexed positionManager);\\n\\n  /**\\n   * @dev Emitted when a position manager is revoked by the user.\\n   * @param user The user address\\n   * @param positionManager The address of the position manager\\n   */\\n  event PositionManagerRevoked(address indexed user, address indexed positionManager);\\n\\n  /**\\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n  /**\\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param deadline The deadline timestamp that the permit is valid\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param permitV The V parameter of ERC712 permit sig\\n   * @param permitR The R parameter of ERC712 permit sig\\n   * @param permitS The S parameter of ERC712 permit sig\\n   */\\n  function supplyWithPermit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode,\\n    uint256 deadline,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external;\\n\\n  /**\\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to The address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   */\\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\\n\\n  /**\\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 variable debt tokens\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   */\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   */\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    address onBehalfOf\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @param deadline The deadline timestamp that the permit is valid\\n   * @param permitV The V parameter of ERC712 permit sig\\n   * @param permitR The R parameter of ERC712 permit sig\\n   * @param permitS The S parameter of ERC712 permit sig\\n   * @return The final amount repaid\\n   */\\n  function repayWithPermit(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    address onBehalfOf,\\n    uint256 deadline,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\\n   * equivalent debt tokens\\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens\\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\\n   * balance is not enough to cover the whole debt\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode DEPRECATED in v3.2.0\\n   * @return The final amount repaid\\n   */\\n  function repayWithATokens(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\n   * @param asset The address of the underlying asset supplied\\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\n   */\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param borrower The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   */\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address borrower,\\n    uint256 debtToCover,\\n    bool receiveAToken\\n  ) external;\\n\\n  /**\\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n   * into consideration. For further details please visit https://docs.aave.com/developers/\\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts of the assets being flash-borrowed\\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Deprecated on v3.2.0\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using 2 on `modes`\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata interestRateModes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n   * into consideration. For further details please visit https://docs.aave.com/developers/\\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\n   * @param asset The address of the asset being flash-borrowed\\n   * @param amount The amount of the asset being flash-borrowed\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function flashLoanSimple(\\n    address receiverAddress,\\n    address asset,\\n    uint256 amount,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\\n   * @return currentLiquidationThreshold The liquidation threshold of the user\\n   * @return ltv The loan to value of The user\\n   * @return healthFactor The current health factor of the user\\n   */\\n  function getUserAccountData(\\n    address user\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralBase,\\n      uint256 totalDebtBase,\\n      uint256 availableBorrowsBase,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\n   */\\n  function initReserve(address asset, address aTokenAddress, address variableDebtAddress) external;\\n\\n  /**\\n   * @notice Drop a reserve\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.\\n   * @param asset The address of the underlying asset of the reserve\\n   */\\n  function dropReserve(address asset) external;\\n\\n  /**\\n   * @notice Accumulates interest to all indexes of the reserve\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\\n   * @param asset The address of the underlying asset of the reserve\\n   */\\n  function syncIndexesState(address asset) external;\\n\\n  /**\\n   * @notice Updates interest rates on the reserve data\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @dev To be used when required by the configurator, for example when updating interest rates strategy data\\n   * @param asset The address of the underlying asset of the reserve\\n   */\\n  function syncRatesState(address asset) external;\\n\\n  /**\\n   * @notice Sets the configuration bitmap of the reserve as a whole\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param configuration The new configuration bitmap\\n   */\\n  function setConfiguration(\\n    address asset,\\n    DataTypes.ReserveConfigurationMap calldata configuration\\n  ) external;\\n\\n  /**\\n   * @notice Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   */\\n  function getConfiguration(\\n    address asset\\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @notice Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   */\\n  function getUserConfiguration(\\n    address user\\n  ) external view returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @notice Returns the normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the normalized variable debt per unit of asset\\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\\n   * \\\"dynamic\\\" variable index based on time, current stored index and virtual rate at the current\\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\\n   * combination with variable debt supply/balances.\\n   * If using this function externally, consider that is possible to have an increasing normalized\\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\\n   * (e.g. only updates with non-zero variable debt supply)\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state and configuration data of the reserve\\n   */\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);\\n\\n  /**\\n   * @notice Returns the virtual underlying balance of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve virtual underlying balance\\n   */\\n  function getVirtualUnderlyingBalance(address asset) external view returns (uint128);\\n\\n  /**\\n   * @notice Validates and finalizes an aToken transfer\\n   * @dev Only callable by the overlying aToken of the `asset`\\n   * @param asset The address of the underlying asset of the aToken\\n   * @param from The user from which the aTokens are transferred\\n   * @param to The user receiving the aTokens\\n   * @param scaledAmount The scaled amount being transferred/withdrawn\\n   * @param scaledBalanceFromBefore The aToken scaled balance of the `from` user before the transfer\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 scaledAmount,\\n    uint256 scaledBalanceFromBefore\\n  ) external;\\n\\n  /**\\n   * @notice Returns the list of the underlying assets of all the initialized reserves\\n   * @dev It does not include dropped reserves\\n   * @return The addresses of the underlying assets of the initialized reserves\\n   */\\n  function getReservesList() external view returns (address[] memory);\\n\\n  /**\\n   * @notice Returns the number of initialized reserves\\n   * @dev It includes dropped reserves\\n   * @return The count\\n   */\\n  function getReservesCount() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\\n   * @return The address of the reserve associated with id\\n   */\\n  function getReserveAddressById(uint16 id) external view returns (address);\\n\\n  /**\\n   * @notice Returns the PoolAddressesProvider connected to this contract\\n   * @return The address of the PoolAddressesProvider\\n   */\\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\\n\\n  /**\\n   * @notice Returns the ReserveInterestRateStrategy connected to all the reserves\\n   * @return The address of the ReserveInterestRateStrategy contract\\n   */\\n  function RESERVE_INTEREST_RATE_STRATEGY() external view returns (address);\\n\\n  /**\\n   * @notice Updates flash loan premium. All this premium is collected by the protocol treasury.\\n   * @dev The premium is calculated on the total borrowed amount\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param flashLoanPremium The flash loan premium, expressed in bps\\n   */\\n  function updateFlashloanPremium(uint128 flashLoanPremium) external;\\n\\n  /**\\n   * @notice Configures a new or alters an existing collateral configuration of an eMode.\\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\\n   * The category 0 is reserved as it's the default for volatile assets\\n   * @param id The id of the category\\n   * @param config The configuration of the category\\n   */\\n  function configureEModeCategory(\\n    uint8 id,\\n    DataTypes.EModeCategoryBaseConfiguration memory config\\n  ) external;\\n\\n  /**\\n   * @notice Replaces the current eMode collateralBitmap.\\n   * @param id The id of the category\\n   * @param collateralBitmap The collateralBitmap of the category\\n   */\\n  function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;\\n\\n  /**\\n   * @notice Replaces the current eMode borrowableBitmap.\\n   * @param id The id of the category\\n   * @param borrowableBitmap The borrowableBitmap of the category\\n   */\\n  function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;\\n\\n  /**\\n   * @notice Replaces the current eMode ltvzeroBitmap.\\n   * @param id The id of the category\\n   * @param ltvzeroBitmap The ltvzeroBitmap of the category\\n   */\\n  function configureEModeCategoryLtvzeroBitmap(uint8 id, uint128 ltvzeroBitmap) external;\\n\\n  /**\\n   * @notice Returns the data of an eMode category\\n   * @dev DEPRECATED use independent getters instead\\n   * @param id The id of the category\\n   * @return The configuration data of the category\\n   */\\n  function getEModeCategoryData(\\n    uint8 id\\n  ) external view returns (DataTypes.EModeCategoryLegacy memory);\\n\\n  /**\\n   * @notice Returns the label of an eMode category\\n   * @dev This function is deprecated and will be removed in a future version.\\n   * @custom:deprecated\\n   * @param id The id of the category\\n   * @return The label of the category\\n   */\\n  function getEModeCategoryLabel(uint8 id) external view returns (string memory);\\n\\n  /**\\n   * @notice Returns the collateral config of an eMode category\\n   * @param id The id of the category\\n   * @return The ltv,lt,lb of the category\\n   */\\n  function getEModeCategoryCollateralConfig(\\n    uint8 id\\n  ) external view returns (DataTypes.CollateralConfig memory);\\n\\n  /**\\n   * @notice Returns the collateralBitmap of an eMode category\\n   * @param id The id of the category\\n   * @return The collateralBitmap of the category\\n   */\\n  function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the borrowableBitmap of an eMode category\\n   * @param id The id of the category\\n   * @return The borrowableBitmap of the category\\n   */\\n  function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the ltvzero of an eMode category\\n   * @param id The id of the category\\n   * @return The ltvzeroBitmap of the category\\n   */\\n  function getEModeCategoryLtvzeroBitmap(uint8 id) external view returns (uint128);\\n\\n  /**\\n   * @notice Allows a user to use the protocol in eMode\\n   * @param categoryId The id of the category\\n   */\\n  function setUserEMode(uint8 categoryId) external;\\n\\n  /**\\n   * @notice Returns the eMode the user is using\\n   * @param user The address of the user\\n   * @return The eMode id\\n   */\\n  function getUserEMode(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Resets the isolation mode total debt of the given asset to zero\\n   * @dev It requires the given asset has zero debt ceiling\\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\\n   */\\n  function resetIsolationModeTotalDebt(address asset) external;\\n\\n  /**\\n   * @notice Sets the liquidation grace period of the given asset\\n   * @dev To enable a liquidation grace period, a timestamp in the future should be set,\\n   *      To disable a liquidation grace period, any timestamp in the past works, like 0\\n   * @param asset The address of the underlying asset to set the liquidationGracePeriod\\n   * @param until Timestamp when the liquidation grace period will end\\n   **/\\n  function setLiquidationGracePeriod(address asset, uint40 until) external;\\n\\n  /**\\n   * @notice Returns the liquidation grace period of the given asset\\n   * @param asset The address of the underlying asset\\n   * @return Timestamp when the liquidation grace period will end\\n   **/\\n  function getLiquidationGracePeriod(address asset) external view returns (uint40);\\n\\n  /**\\n   * @notice Returns the total fee on flash loans.\\n   * @dev From v3.4 all flashloan fees will be send to the treasury.\\n   * @return The total fee on flashloans\\n   */\\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the part of the flashloan fees sent to protocol\\n   * @dev From v3.4 all flashloan fees will be send to the treasury and this value\\n   *      is always 100_00.\\n   * @return The flashloan fee sent to the protocol treasury\\n   */\\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\\n   * @return The maximum number of reserves supported\\n   */\\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\\n\\n  /**\\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\\n   * @param assets The list of reserves for which the minting needs to be executed\\n   */\\n  function mintToTreasury(address[] calldata assets) external;\\n\\n  /**\\n   * @notice Rescue and transfer tokens locked in this contract\\n   * @param token The address of the token\\n   * @param to The address of the recipient\\n   * @param amount The amount of token to transfer\\n   */\\n  function rescueTokens(address token, address to, uint256 amount) external;\\n\\n  /**\\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n   * @dev Deprecated: Use the `supply` function instead\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n  /**\\n   * @notice It covers the deficit of a specified reserve by burning the equivalent aToken `amount` for assets\\n   * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.\\n   * @param asset The address of the underlying asset to cover the deficit.\\n   * @param amount The amount to be covered, in aToken\\n   * @return The amount of tokens burned\\n   */\\n  function eliminateReserveDeficit(address asset, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Approves or disapproves a position manager. This position manager will be able\\n   * to call the `setUserUseReserveAsCollateralOnBehalfOf` and the\\n   * `setUserEModeOnBehalfOf` function on behalf of the user.\\n   * @param positionManager The address of the position manager\\n   * @param approve True if the position manager should be approved, false otherwise\\n   */\\n  function approvePositionManager(address positionManager, bool approve) external;\\n\\n  /**\\n   * @notice Renounces a position manager role for a given user.\\n   * @param user The address of the user\\n   */\\n  function renouncePositionManagerRole(address user) external;\\n\\n  /**\\n   * @notice Sets the use as collateral flag for the user on the specific reserve on behalf of the user.\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param useAsCollateral True if the user wants to use the reserve as collateral, false otherwise\\n   * @param onBehalfOf The address of the user\\n   */\\n  function setUserUseReserveAsCollateralOnBehalfOf(\\n    address asset,\\n    bool useAsCollateral,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Sets the eMode category for the user on the specific reserve on behalf of the user.\\n   * @param categoryId The id of the category\\n   * @param onBehalfOf The address of the user\\n   */\\n  function setUserEModeOnBehalfOf(uint8 categoryId, address onBehalfOf) external;\\n\\n  /*\\n   * @notice Returns true if the `positionManager` address is approved to use the position manager role on behalf of the user.\\n   * @param user The address of the user\\n   * @param positionManager The address of the position manager\\n   * @return True if the user is approved to use the position manager, false otherwise\\n   */\\n  function isApprovedPositionManager(\\n    address user,\\n    address positionManager\\n  ) external view returns (bool);\\n\\n  /**\\n   * @notice Returns the current deficit of a reserve.\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The current deficit of the reserve\\n   */\\n  function getReserveDeficit(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the aToken address of a reserve.\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The address of the aToken\\n   */\\n  function getReserveAToken(address asset) external view returns (address);\\n\\n  /**\\n   * @notice Returns the variableDebtToken address of a reserve.\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The address of the variableDebtToken\\n   */\\n  function getReserveVariableDebtToken(address asset) external view returns (address);\\n\\n  /**\\n   * @notice Gets the address of the external FlashLoanLogic\\n   */\\n  function getFlashLoanLogic() external view returns (address);\\n\\n  /**\\n   * @notice Gets the address of the external BorrowLogic\\n   */\\n  function getBorrowLogic() external view returns (address);\\n\\n  /**\\n   * @notice Gets the address of the external LiquidationLogic\\n   */\\n  function getLiquidationLogic() external view returns (address);\\n\\n  /**\\n   * @notice Gets the address of the external PoolLogic\\n   */\\n  function getPoolLogic() external view returns (address);\\n\\n  /**\\n   * @notice Gets the address of the external SupplyLogic\\n   */\\n  function getSupplyLogic() external view returns (address);\\n}\\n\",\"keccak256\":\"0x4ec906a86eea7beb7295369af408b23e42235a791b0c5ed49bd5d9d496b4e00b\",\"license\":\"MIT\"},\"lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n  /**\\n   * @dev Emitted when the market identifier is updated.\\n   * @param oldMarketId The old id of the market\\n   * @param newMarketId The new id of the market\\n   */\\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n\\n  /**\\n   * @dev Emitted when the pool is updated.\\n   * @param oldAddress The old address of the Pool\\n   * @param newAddress The new address of the Pool\\n   */\\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool configurator is updated.\\n   * @param oldAddress The old address of the PoolConfigurator\\n   * @param newAddress The new address of the PoolConfigurator\\n   */\\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle is updated.\\n   * @param oldAddress The old address of the PriceOracle\\n   * @param newAddress The new address of the PriceOracle\\n   */\\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL manager is updated.\\n   * @param oldAddress The old address of the ACLManager\\n   * @param newAddress The new address of the ACLManager\\n   */\\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL admin is updated.\\n   * @param oldAddress The old address of the ACLAdmin\\n   * @param newAddress The new address of the ACLAdmin\\n   */\\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle sentinel is updated.\\n   * @param oldAddress The old address of the PriceOracleSentinel\\n   * @param newAddress The new address of the PriceOracleSentinel\\n   */\\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool data provider is updated.\\n   * @param oldAddress The old address of the PoolDataProvider\\n   * @param newAddress The new address of the PoolDataProvider\\n   */\\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when a new proxy is created.\\n   * @param id The identifier of the proxy\\n   * @param proxyAddress The address of the created proxy contract\\n   * @param implementationAddress The address of the implementation contract\\n   */\\n  event ProxyCreated(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address indexed implementationAddress\\n  );\\n\\n  /**\\n   * @dev Emitted when a new non-proxied contract address is registered.\\n   * @param id The identifier of the contract\\n   * @param oldAddress The address of the old contract\\n   * @param newAddress The address of the new contract\\n   */\\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the implementation of the proxy registered with id is updated\\n   * @param id The identifier of the contract\\n   * @param proxyAddress The address of the proxy contract\\n   * @param oldImplementationAddress The address of the old implementation contract\\n   * @param newImplementationAddress The address of the new implementation contract\\n   */\\n  event AddressSetAsProxy(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address oldImplementationAddress,\\n    address indexed newImplementationAddress\\n  );\\n\\n  /**\\n   * @notice Returns the id of the Aave market to which this contract points to.\\n   * @return The market id\\n   */\\n  function getMarketId() external view returns (string memory);\\n\\n  /**\\n   * @notice Associates an id with a specific PoolAddressesProvider.\\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n   * identify and validate multiple Aave markets.\\n   * @param newMarketId The market id\\n   */\\n  function setMarketId(string calldata newMarketId) external;\\n\\n  /**\\n   * @notice Returns an address by its identifier.\\n   * @dev The returned address might be an EOA or a contract, potentially proxied\\n   * @dev It returns ZERO if there is no registered address with the given id\\n   * @param id The id\\n   * @return The address of the registered for the specified id\\n   */\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  /**\\n   * @notice General function to update the implementation of a proxy registered with\\n   * certain `id`. If there is no proxy registered, it will instantiate one and\\n   * set as implementation the `newImplementationAddress`.\\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n   * setter function, in order to avoid unexpected consequences\\n   * @param id The id\\n   * @param newImplementationAddress The address of the new implementation\\n   */\\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\\n\\n  /**\\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n   * @param id The id\\n   * @param newAddress The address to set\\n   */\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  /**\\n   * @notice Returns the address of the Pool proxy.\\n   * @return The Pool proxy address\\n   */\\n  function getPool() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the Pool, or creates a proxy\\n   * setting the new `pool` implementation when the function is called for the first time.\\n   * @param newPoolImpl The new Pool implementation\\n   */\\n  function setPoolImpl(address newPoolImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the PoolConfigurator proxy.\\n   * @return The PoolConfigurator proxy address\\n   */\\n  function getPoolConfigurator() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n   */\\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle.\\n   * @return The address of the PriceOracle\\n   */\\n  function getPriceOracle() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle.\\n   * @param newPriceOracle The address of the new PriceOracle\\n   */\\n  function setPriceOracle(address newPriceOracle) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL manager.\\n   * @return The address of the ACLManager\\n   */\\n  function getACLManager() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL manager.\\n   * @param newAclManager The address of the new ACLManager\\n   */\\n  function setACLManager(address newAclManager) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL admin.\\n   * @return The address of the ACL admin\\n   */\\n  function getACLAdmin() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL admin.\\n   * @param newAclAdmin The address of the new ACL admin\\n   */\\n  function setACLAdmin(address newAclAdmin) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle sentinel.\\n   * @return The address of the PriceOracleSentinel\\n   */\\n  function getPriceOracleSentinel() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle sentinel.\\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n   */\\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n\\n  /**\\n   * @notice Returns the address of the data provider.\\n   * @return The address of the DataProvider\\n   */\\n  function getPoolDataProvider() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the data provider.\\n   * @param newDataProvider The address of the new DataProvider\\n   */\\n  function setPoolDataProvider(address newDataProvider) external;\\n}\\n\",\"keccak256\":\"0xa60921cf54e91ca8db038effeffc876089b2e72dbf01d68a10ff461770d345e5\",\"license\":\"MIT\"},\"lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n  /**\\n   * This exists specifically to maintain the `getReserveData()` interface, since the new, internal\\n   * `ReserveData` struct includes the reserve's `virtualUnderlyingBalance`.\\n   */\\n  struct ReserveDataLegacy {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    // DEPRECATED on v3.2.0\\n    uint128 currentStableBorrowRate;\\n    //timestamp of last update\\n    uint40 lastUpdateTimestamp;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint16 id;\\n    //aToken address\\n    address aTokenAddress;\\n    // DEPRECATED on v3.2.0\\n    address stableDebtTokenAddress;\\n    //variableDebtToken address\\n    address variableDebtTokenAddress;\\n    // DEPRECATED on v3.4.0, should use the `RESERVE_INTEREST_RATE_STRATEGY` variable from the Pool contract\\n    address interestRateStrategyAddress;\\n    //the current treasury balance, scaled\\n    uint128 accruedToTreasury;\\n    // DEPRECATED on v3.4.0\\n    uint128 unbacked;\\n    //the outstanding debt borrowed against this asset in isolation mode\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    /// @notice reused `__deprecatedStableBorrowRate` storage from pre 3.2\\n    // the current accumulate deficit in underlying tokens\\n    uint128 deficit;\\n    //timestamp of last update\\n    uint40 lastUpdateTimestamp;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint16 id;\\n    //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed\\n    uint40 liquidationGracePeriodUntil;\\n    //aToken address\\n    address aTokenAddress;\\n    // DEPRECATED on v3.2.0\\n    address __deprecatedStableDebtTokenAddress;\\n    //variableDebtToken address\\n    address variableDebtTokenAddress;\\n    // DEPRECATED on v3.4.0, should use the `RESERVE_INTEREST_RATE_STRATEGY` variable from the Pool contract\\n    address __deprecatedInterestRateStrategyAddress;\\n    //the current treasury balance, scaled\\n    uint128 accruedToTreasury;\\n    // In aave 3.3.0 this storage slot contained the `unbacked`\\n    uint128 virtualUnderlyingBalance;\\n    //the outstanding debt borrowed against this asset in isolation mode\\n    uint128 isolationModeTotalDebt;\\n    //the amount of underlying accounted for by the protocol\\n    // DEPRECATED on v3.4.0. Moved into the same slot as accruedToTreasury for optimized storage access.\\n    uint128 __deprecatedVirtualUnderlyingBalance;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: DEPRECATED: stable rate borrowing enabled\\n    //bit 60: asset is paused\\n    //bit 61: borrowing in isolation mode is enabled\\n    //bit 62: siloed borrowing enabled\\n    //bit 63: flashloaning enabled\\n    //bit 64-79: reserve factor\\n    //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap\\n    //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap\\n    //bit 152-167: liquidation protocol fee\\n    //bit 168-175: DEPRECATED: eMode category\\n    //bit 176-211: DEPRECATED: unbacked mint cap\\n    //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n    //bit 252: DEPRECATED: virtual accounting is enabled for the reserve\\n    //bit 253-255 unused\\n\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    /**\\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n     * asset is borrowed by the user.\\n     */\\n    uint256 data;\\n  }\\n\\n  // DEPRECATED: kept for backwards compatibility, might be removed in a future version\\n  struct EModeCategoryLegacy {\\n    // each eMode category has a custom ltv and liquidation threshold\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    // DEPRECATED\\n    address priceSource;\\n    string label;\\n  }\\n\\n  struct CollateralConfig {\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n  }\\n\\n  struct EModeCategoryBaseConfiguration {\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    string label;\\n  }\\n\\n  struct EModeCategory {\\n    // each eMode category has a custom ltv and liquidation threshold\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    uint128 collateralBitmap;\\n    string label;\\n    uint128 borrowableBitmap;\\n    uint128 ltvzeroBitmap; // if true, the asset will be treated as ltv0 and ltv0 rules apply\\n  }\\n\\n  enum InterestRateMode {\\n    NONE,\\n    __DEPRECATED,\\n    VARIABLE\\n  }\\n\\n  struct ReserveCache {\\n    uint256 currScaledVariableDebt;\\n    uint256 nextScaledVariableDebt;\\n    uint256 currLiquidityIndex;\\n    uint256 nextLiquidityIndex;\\n    uint256 currVariableBorrowIndex;\\n    uint256 nextVariableBorrowIndex;\\n    uint256 currLiquidityRate;\\n    uint256 currVariableBorrowRate;\\n    uint256 reserveFactor;\\n    ReserveConfigurationMap reserveConfiguration;\\n    address aTokenAddress;\\n    address variableDebtTokenAddress;\\n    uint40 reserveLastUpdateTimestamp;\\n  }\\n\\n  struct ExecuteLiquidationCallParams {\\n    address liquidator;\\n    uint256 debtToCover;\\n    address collateralAsset;\\n    address debtAsset;\\n    address borrower;\\n    bool receiveAToken;\\n    address priceOracle;\\n    uint8 borrowerEModeCategory;\\n    address priceOracleSentinel;\\n    address interestRateStrategyAddress;\\n  }\\n\\n  struct ExecuteSupplyParams {\\n    address user;\\n    address asset;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n    uint8 supplierEModeCategory;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address asset;\\n    address user;\\n    address onBehalfOf;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint16 referralCode;\\n    bool releaseUnderlying;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address asset;\\n    address user;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    address onBehalfOf;\\n    bool useATokens;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address user;\\n    address asset;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n    address to;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ExecuteEliminateDeficitParams {\\n    address user;\\n    address asset;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n  }\\n\\n  struct FinalizeTransferParams {\\n    address asset;\\n    address from;\\n    address to;\\n    uint256 scaledAmount;\\n    uint256 scaledBalanceFromBefore;\\n    address oracle;\\n    uint8 fromEModeCategory;\\n  }\\n\\n  struct FlashloanParams {\\n    address user;\\n    address receiverAddress;\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] interestRateModes;\\n    address interestRateStrategyAddress;\\n    address onBehalfOf;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremium;\\n    address addressesProvider;\\n    address pool;\\n    uint8 userEModeCategory;\\n    bool isAuthorizedFlashBorrower;\\n  }\\n\\n  struct FlashloanSimpleParams {\\n    address user;\\n    address receiverAddress;\\n    address asset;\\n    address interestRateStrategyAddress;\\n    uint256 amount;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremium;\\n  }\\n\\n  struct FlashLoanRepaymentParams {\\n    address user;\\n    uint256 amount;\\n    uint256 totalPremium;\\n    address asset;\\n    address interestRateStrategyAddress;\\n    address receiverAddress;\\n    uint16 referralCode;\\n  }\\n\\n  struct CalculateUserAccountDataParams {\\n    UserConfigurationMap userConfig;\\n    address user;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ValidateBorrowParams {\\n    ReserveCache reserveCache;\\n    UserConfigurationMap userConfig;\\n    address asset;\\n    address userAddress;\\n    uint256 amountScaled;\\n    InterestRateMode interestRateMode;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ValidateLiquidationCallParams {\\n    ReserveCache debtReserveCache;\\n    uint256 totalDebt;\\n    uint256 healthFactor;\\n    address priceOracleSentinel;\\n    address borrower;\\n    address liquidator;\\n  }\\n\\n  struct CalculateInterestRatesParams {\\n    uint256 unbacked;\\n    uint256 liquidityAdded;\\n    uint256 liquidityTaken;\\n    uint256 totalDebt;\\n    uint256 reserveFactor;\\n    address reserve;\\n    // @notice DEPRECATED in 3.4, but kept for backwards compatibility\\n    bool usingVirtualBalance;\\n    uint256 virtualUnderlyingBalance;\\n  }\\n\\n  struct InitReserveParams {\\n    address asset;\\n    address aTokenAddress;\\n    address variableDebtAddress;\\n    uint16 reservesCount;\\n    uint16 maxNumberReserves;\\n  }\\n}\\n\",\"keccak256\":\"0x21b8178157eea76394488a0e1125e2151b0c31c576d9cbf7db1bc0415dbbe2e0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610363610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c80635f90e91f14610038575b5f5ffd5b61004b61004636600461011f565b610074565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6040516335ea6a7560e01b815273ffffffffffffffffffffffffffffffffffffffff82811660048301525f9182918516906335ea6a75906024016101e060405180830381865afa1580156100ca573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100ee919061022c565b6101000151949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461011c575f5ffd5b50565b5f5f60408385031215610130575f5ffd5b823561013b816100fb565b9150602083013561014b816100fb565b809150509250929050565b6040516101e0810167ffffffffffffffff8111828210171561018657634e487b7160e01b5f52604160045260245ffd5b60405290565b5f6020828403121561019c575f5ffd5b6040516020810167ffffffffffffffff811182821017156101cb57634e487b7160e01b5f52604160045260245ffd5b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff811681146101f7575f5ffd5b919050565b805164ffffffffff811681146101f7575f5ffd5b805161ffff811681146101f7575f5ffd5b80516101f7816100fb565b5f6101e082840312801561023e575f5ffd5b50610247610156565b610251848461018c565b815261025f602084016101d8565b6020820152610270604084016101d8565b6040820152610281606084016101d8565b6060820152610292608084016101d8565b60808201526102a360a084016101d8565b60a08201526102b460c084016101fc565b60c08201526102c560e08401610210565b60e08201526102d76101008401610221565b6101008201526102ea6101208401610221565b6101208201526102fd6101408401610221565b6101408201526103106101608401610221565b61016082015261032361018084016101d8565b6101808201526103366101a084016101d8565b6101a08201526103496101c084016101d8565b6101c0820152939250505056fea164736f6c634300081b000a",
  "deployedBytecode": "0x7300000000000000000000000000000000000000003014608060405260043610610034575f3560e01c80635f90e91f14610038575b5f5ffd5b61004b61004636600461011f565b610074565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6040516335ea6a7560e01b815273ffffffffffffffffffffffffffffffffffffffff82811660048301525f9182918516906335ea6a75906024016101e060405180830381865afa1580156100ca573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906100ee919061022c565b6101000151949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461011c575f5ffd5b50565b5f5f60408385031215610130575f5ffd5b823561013b816100fb565b9150602083013561014b816100fb565b809150509250929050565b6040516101e0810167ffffffffffffffff8111828210171561018657634e487b7160e01b5f52604160045260245ffd5b60405290565b5f6020828403121561019c575f5ffd5b6040516020810167ffffffffffffffff811182821017156101cb57634e487b7160e01b5f52604160045260245ffd5b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff811681146101f7575f5ffd5b919050565b805164ffffffffff811681146101f7575f5ffd5b805161ffff811681146101f7575f5ffd5b80516101f7816100fb565b5f6101e082840312801561023e575f5ffd5b50610247610156565b610251848461018c565b815261025f602084016101d8565b6020820152610270604084016101d8565b6040820152610281606084016101d8565b6060820152610292608084016101d8565b60808201526102a360a084016101d8565b60a08201526102b460c084016101fc565b60c08201526102c560e08401610210565b60e08201526102d76101008401610221565b6101008201526102ea6101208401610221565b6101208201526102fd6101408401610221565b6101408201526103106101608401610221565b61016082015261032361018084016101d8565b6101808201526103366101a084016101d8565b6101a08201526103496101c084016101d8565b6101c0820152939250505056fea164736f6c634300081b000a",
  "devdoc": {
    "details": "AAVE Documentation https://github.com/aave-dao/aave-v3-origin",
    "events": {
      "LiquiditySupplied(uint256)": {
        "params": {
          "amount": "Amount supplied"
        }
      },
      "LiquidityWithdrawn(uint256)": {
        "params": {
          "amount": "Amount withdrawn"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "fetchAssets(address,address)": {
        "params": {
          "pool": "AAVE pool address",
          "underlying": "Underlying asset address"
        },
        "returns": {
          "_0": "aToken address"
        }
      }
    },
    "title": "AaveAdapter",
    "version": 1
  },
  "userdoc": {
    "events": {
      "LiquiditySupplied(uint256)": {
        "notice": "Emitted when liquidity is supplied to AAVE"
      },
      "LiquidityWithdrawn(uint256)": {
        "notice": "Emitted when liquidity is withdrawn from AAVE"
      }
    },
    "kind": "user",
    "methods": {
      "fetchAssets(address,address)": {
        "notice": "Fetch the aToken address for a given underlying asset from AAVE pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}